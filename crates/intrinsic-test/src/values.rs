pub const MAX_SVE_BITS: u32 = 2048;

// All SVE vector lengths must be a multiple of this granule size
pub const SVE_GRANULE_BITS: u32 = 128;

/// Get a single value for an argument values array in a determistic way.
/// * `bits`: The number of bits for the type, only 8, 16, 32, 64 are valid values
/// * `index`: The position in the array we are generating for
pub fn value_for_array(bits: u32, index: u32) -> u64 {
    let index = index as usize;
    match bits {
        8 => VALUES_8[index % VALUES_8.len()].into(),
        16 => VALUES_16[index % VALUES_16.len()].into(),
        32 => VALUES_32[index % VALUES_32.len()].into(),
        64 => VALUES_64[index % VALUES_64.len()].into(),
        _ => unimplemented!("value_for_array(bits: {bits}, ..)"),
    }
}

pub const VALUES_8: &[u8] = &[
    0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11,
    0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21,
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
    0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
    0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51,
    0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61,
    0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71,
    0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81,
    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1,
    0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1,
    0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1,
    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1,
    0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1,
    0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
    0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
];

pub const VALUES_16: &[u16] = &[
    0x0000, // 0.0
    0x0400, // The smallest normal value.
    0x37ff, // The value just below 0.5.
    0x3800, // 0.5
    0x3801, // The value just above 0.5.
    0x3bff, // The value just below 1.0.
    0x3c00, // 1.0
    0x3c01, // The value just above 1.0.
    0x3e00, // 1.5
    0x4900, // 10
    0x7bff, // The largest finite value.
    0x7c00, // Infinity.
    // NaNs.
    //  - Quiet NaNs
    0x7f23, 0x7e00, //  - Signalling NaNs
    0x7d23, 0x7c01, // Subnormals.
    //  - A recognisable bit pattern.
    0x0012, //  - The largest subnormal value.
    0x03ff, //  - The smallest subnormal value.
    0x0001, // The same values again, but negated.
    0x8000, 0x8400, 0xb7ff, 0xb800, 0xb801, 0xbbff, 0xbc00, 0xbc01, 0xbe00, 0xc900, 0xfbff, 0xfc00,
    0xff23, 0xfe00, 0xfd23, 0xfc01, 0x8012, 0x83ff, 0x8001,
    0x3555, // As close to 1/3 as possible.
    // Random values.
    0xfc00, 0xc000, 0x5140, 0x5800, 0x63d2, 0x5630, 0x3560, 0x9191, 0x4178, 0x6212, 0x67d0, 0x3312,
    0x4cef, 0x4973, 0x3ecc, 0x5166, 0x4d80, 0x6248, 0x46fd, 0x39c4, 0x39c5, 0x4866, 0x6050, 0x498e,
    0x4a0f, // The previous values in a different order.
    0x3555, 0xfc00, 0xc000, 0x9191, 0x5140, 0x5800, 0x8001, 0x83ff, 0x63d2, 0x5630, 0x3560, 0x4178,
    0x7d23, 0x7c01, 0x0012, 0xb800, 0x03ff, 0x0001, 0x7e00, 0x7f23, 0x8000, 0x8400, 0xb7ff, 0xb801,
    0x3312, 0x4cef, 0x4973, 0x39c4, 0x3ecc, 0x5166, 0x67d0, 0x6212, 0x4d80, 0x6248, 0x46fd, 0x39c5,
    0xbc01, 0xbe00, 0xc900, 0xfc01, 0xfbff, 0xfc00, 0xbc00, 0xbbff, 0xff23, 0xfe00, 0xfd23, 0x8012,
    0x37ff, 0x3800, 0x3801, 0x7bff, 0x3bff, 0x3c00, 0x0400, 0x0000, 0x3c01, 0x3e00, 0x4900, 0x7c00,
    0x498e, 0x4a0f, 0x6050, 0x4866,
];

pub const VALUES_32: &[u32] = &[
    // Simple values.
    0x00000000, // 0.0
    0x00800000, // The smallest normal value.
    0x3effffff, // The value just below 0.5.
    0x3f000000, // 0.5
    0x3f000001, // The value just above 0.5.
    0x3f7fffff, // The value just below 1.0.
    0x3f800000, // 1.0
    0x3f800001, // The value just above 1.0.
    0x3fc00000, // 1.5
    0x41200000, // 10
    0x7f8fffff, // The largest finite value.
    0x7f800000, // Infinity.
    // NaNs.
    //  - Quiet NaNs
    0x7fd23456, 0x7fc00000, //  - Signalling NaNs
    0x7f923456, 0x7f800001, // Subnormals.
    //  - A recognisable bit pattern.
    0x00123456, //  - The largest subnormal value.
    0x007fffff, //  - The smallest subnormal value.
    0x00000001, // The same values again, but negated.
    0x80000000, 0x80800000, 0xbeffffff, 0xbf000000, 0xbf000001, 0xbf7fffff, 0xbf800000, 0xbf800001,
    0xbfc00000, 0xc1200000, 0xff8fffff, 0xff800000, 0xffd23456, 0xffc00000, 0xff923456, 0xff800001,
    0x80123456, 0x807fffff, 0x80000001, 0x40490fdb, // Approximately pi.
    0x3eaaaaab, // Approximately 1/3.
    // Random values.
    0x4205cccd, 0x4229178D, 0x42C6A0C5, 0x3B3302F7, 0x3F9DF45E, 0x41DAA3D7, 0x47C3501D, 0xC3889333,
    0xC2C675C3, 0xC69C449A, 0xC341FD71, 0xC502DFD7, 0xBBB43958, 0x3EE24DD3, 0x42B1C28F, 0x42F06666,
    0x45D379C3, 0x44637148, 0x3CBBECAB, 0x4113EDFA, 0x444B22F2, 0x1FD93A96, 0x9921055F, 0xFF626925,
];

pub const VALUES_64: &[u64] = &[
    // Simple values.
    0x0000000000000000, // 0.0
    0x0010000000000000, // The smallest normal value.
    0x3fdfffffffffffff, // The value just below 0.5.
    0x3fe0000000000000, // 0.5
    0x3fe0000000000001, // The value just above 0.5.
    0x3fefffffffffffff, // The value just below 1.0.
    0x3ff0000000000000, // 1.0
    0x3ff0000000000001, // The value just above 1.0.
    0x3ff8000000000000, // 1.5
    0x4024000000000000, // 10
    0x7fefffffffffffff, // The largest finite value.
    0x7ff0000000000000, // Infinity.
    // NaNs.
    //  - Quiet NaNs
    0x7ff923456789abcd,
    0x7ff8000000000000,
    //  - Signalling NaNs
    0x7ff123456789abcd,
    0x7ff0000000000000,
    // Subnormals.
    //  - A recognisable bit pattern.
    0x000123456789abcd,
    //  - The largest subnormal value.
    0x000fffffffffffff,
    //  - The smallest subnormal value.
    0x0000000000000001,
    // The same values again, but negated.
    0x8000000000000000,
    0x8010000000000000,
    0xbfdfffffffffffff,
    0xbfe0000000000000,
    0xbfe0000000000001,
    0xbfefffffffffffff,
    0xbff0000000000000,
    0xbff0000000000001,
    0xbff8000000000000,
    0xc024000000000000,
    0xffefffffffffffff,
    0xfff0000000000000,
    0xfff923456789abcd,
    0xfff8000000000000,
    0xfff123456789abcd,
    0xfff0000000000000,
    0x800123456789abcd,
    0x800fffffffffffff,
    0x8000000000000001,
    0x400921FB54442D18, // Pi.
    0x3fd5555555555555, // Approximately 1/3.
];

/// Patterns that are used to construct the predicates for predicated intrinsics.
pub const PRED_PATTERNS: &[[bool; 16]] = &[
    [true; 16],
    [false; 16],
    [
        true, false, true, false, true, false, true, false, true, false, true, false, true, false,
        true, false,
    ],
    [
        false, true, false, true, false, true, false, true, false, true, false, true, false, true,
        false, true,
    ],
];
